<html>
    <head>
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="js/xregexp-min.js"></script>
        <script type="text/javascript" src="js/shCore.js"></script>
        <script type="text/javascript" src="js/shBrushClojure.js"></script>
        <script type="text/javascript" src="js/shBrushJScript.js"></script>
        <link rel="stylesheet" type="text/css" href="css/base.css" />
        <link rel="stylesheet" type="text/css" href="css/shCore.css" />
        <link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
        <script type="text/javascript" src="http://use.typekit.com/rvk4jgw.js"></script>
        <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    </head>
    <body>

        <div id="mori-nav">

            <a href="#mori" class="toc-title">Mori</a>
            <br/>

            <a href="#rationale" class="toc-title">Rationale</a>
            <ul>
                <li><a href="#immutability">- Immutability</a></li>
                <li><a href="#island">- Mori is not an island</a></li>
                <li><a href="#usage">- Using Mori</a></li>
                <li><a href="#notation">- Notation</a></li>
            </ul>

            <a href="#fundamentals" class="toc-title">Fundamentals</a>
            <ul>
                <li><a href="#equals">- equals</a></li>
            </ul>

            <a href="#collections" class="toc-title">Collections</a>
            <ul>
                <li><a href="#list">- list</a></li>
                <li><a href="#vector">- vector</a></li>
                <li><a href="#hash_map">- hash_map</a></li>
                <li><a href="#set">- set</a></li>
                <li><a href="#sorted_set">- sorted_set</a></li>
            </ul>

            <a class="toc-title">Collection Operations</a>
            <ul>
                <li><a href="#conj">- conj</a></li>
                <li><a href="#assoc">- assoc</a></li>
                <li><a href="#dissoc">- dissoc</a></li>
                <li><a href="#get">- get</a></li>
                <li><a href="#get_in">- get_in</a></li>
                <li><a href="#has_key">- has_key</a></li>
                <li><a href="#find">- find</a></li>
                <li><a href="#nth">- nth</a></li>
                <li><a href="#assoc_in">- assoc_in</a></li>
                <li><a href="#update_in">- update_in</a></li>
                <li><a href="#count">- count</a></li>
                <li><a href="#peek">- peek</a></li>
                <li><a href="#pop">- pop</a></li>
                <li><a href="#zipmap">- zipmap</a></li>
            </ul>

            <a class="toc-title">Vector Operations</a>
            <ul>
                <li><a href="#disj">- subvec</a></li>
            </ul>

            <a class="toc-title">Set Operations</a>
            <ul>
                <li><a href="#disj">- disj</a></li>
                <li><a href="#union">- union</a></li>
                <li><a href="#intersection">- intersection</a></li>
                <li><a href="#difference">- difference</a></li>
                <li><a href="#is_subset">- is_subset</a></li>
                <li><a href="#is_superset">- is_superset</a></li>
            </ul>

            <a class="toc-title">Sequences</a>
            <ul>
                <li><a href="#first">- first</a></li>
                <li><a href="#rest">- rest</a></li>
                <li><a href="#seq">- seq</a></li>
                <li><a href="#into_array">- into_array</a></li>
                <li><a href="#each">- each</a></li>
                <li><a href="#map">- map</a></li>
                <li><a href="#filter">- filter</a></li>
                <li><a href="#remove">- remove</a></li>
                <li><a href="#reduce">- reduce</a></li>
                <li><a href="#take">- take</a></li>
                <li><a href="#take_while">- take_while</a></li>
                <li><a href="#drop">- drop</a></li>
                <li><a href="#drop_while">- drop_while</a></li>
                <li><a href="#interpose">- interpose</a></li>
                <li><a href="#interleave">- interleave</a></li>
                <li><a href="#repeat">- repeat</a></li>
                <li><a href="#repeatedly">- repeatedly</a></li>
                <li><a href="#partition">- partition</a></li>
                <li><a href="#group_by">- group_by</a></li>
            </ul>

            <a class="toc-title">Helpers</a>
            <ul>
                <li><a href="#prim_seq">- prim_seq</a></li>
                <li><a href="#identity">- identity</a></li>
                <li><a href="#sum">- sum</a></li>
                <li><a href="#inc">- inc</a></li>
                <li><a href="#dec">- dec</a></li>
                <li><a href="#is_even">- is_even</a></li>
                <li><a href="#is_odd">- is_odd</a></li>
                <li><a href="#juxt">- juxt</a></li>
                <li><a href="#knit">- knit</a></li>
                <li><a href="#pipeline">- pipeline</a></li>
                <li><a href="#partial">- partial</a></li>
                <li><a href="#curry">- curry</a></li>
                <li><a href="#curry">- fnil</a></li>
            </ul>
        </div>

        <div id="mori-content">
            <h1 id="mori" class="tk-anisette-petite">mori</h1>

            <p>
                A library for using ClojureScript's persistent data
                structures and supporting API from the comfort of
                vanilla JavaScript.
            </p>

            <h2 id="rationale">Rationale</h2>
            <p>
                JavaScript is a powerful and flexible dynamic
                programming language with a beautiful simple
                associative model at its core. However this design
                comes at the cost of ubiquitous mutability. Mori
                embraces the simple associative model but leaves
                mutability behind. Mori delivers the following
                benefits to JavaScript:
            </p>
            <ul>
                <li>Efficient immutable data structures - no cloning required</li>
                <li>Uniform iteration for all types</li>
                <li>Value based equality</li>
            </ul>
            <p>
                Modern JavaScript engines like V8, JavaScriptCore, and
                SpiderMonkey deliver the performance needed to implement
                peristent data structures well.
            </p>

            <h3 id="immutability">Immutability</h3>
            <p>
                Mori delivers highly tuned persistent data structures
                based on the ones provided in Clojure.  When using
                Mori data structures and operations you do not need to
                defensively clone as you often do in JavaScript.

                By providing immutable data structures, Mori encourages
                value oriented programming.
            </p>

            <h3 id="island">Mori is not an island</h3>
            <p>
                Beyond the the core philosophy Mori makes no other
                assumptions about how you might use it. In fact, Mori
                has changed some aspects of the ClojureScript API in
                order to better accomodate usage from JavaScript and
                languages that target JavaScript like
                CoffeeScript. For example, where it makes sense, Mori
                returns regular JavaScript arrays so that you can use
                destructuring syntax where available.

                The following example is in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
m = mori;
[a, b] = m.juxt(m.inc, m.dec)(1); // a = 2, b = 0
                </pre>
            </div>


            <h3 id="usage">Using Mori</h3>
            <p>
                Mori can be used in precisely the same way that
                libraries like Underscore.js are used. Mori of course
                provides not only the same functionality but it
                delivers a rich set of data structures.
                Mori's operators are more general than the ones
                provided by Underscore.js - they work on nearly all
                the native JavaScript types. In those cases where they
                do not work you usually just need to wrap the type
                in <code>mori.prim_seq(...)</code>.
            </p>

            <h3 id="notation">Notation</h3>
            <p>
                Each entry is annotated with the signature with an
                accompanying description and some relevant
                examples. Optional parameters appear
                as <code>[option]</code> in thhe signature. Sometimes
                the signature or description will mention <b>coll</b>
                for collection. In general collections can be
                converted in to sequences for manipulation via the
                various sequence operations. This include all Mori
                collections as well as JavaScript Arrays and Strings.
            </p>
            <p>
                All the examples are in JavaScript or CoffeeScript. However,
                for simplicity's sake we show the <i>results</i> of operations
                in Clojure literal syntax notation.
            </p>
            <div class="example">
                <pre class="brush: clojure">
(1 2 3 4)              ;; list

[1 2 3 4]              ;; vector

{"foo" 1, "bar" 2}     ;; hash map

#{"cat" "bird" "dog"}  ;; set / sorted-set
                </pre>
            </div>

            <h2 id="collections">Collections</h2>

            <h3 id="list">
                list
                <span class="sig">mori.list(arg0, arg1, ...)</span>
            </h3>
            <p>
                Constructs an immutable list. Lists support efficient
                addition at the head of the list. It's important to
                remember that the cost of operations like
                <code>mori.nth</code> will be linear in the size of
                the list.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list(2,3);

mori.cons(l, 1); // => (1 2 3)
                </pre>
            </div>
                
            <h3 id="vector">
                vector
                <span class="sig">mori.vector(arg0, arg1, ...)</span>
            </h3>
            <p>
                Constructs an immutable vector. Vectors support efficient
                addition at the end. They also support efficient random
                access. You will probaly use <code>mori.vector</code> much
                more often than <code>mori.list</code>
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector(1,2,3,4);
mori.nth(v, 0); // => 1
                </pre>
            </div>
            
            <h3 id="hash_map">
                hash_map
                <span class="sig">mori.hash_map(key0, val0, key1, val1, ...)</span>
            </h3>
            <p>
                Constructs an immutable hash map. Unlike JavaScript
                objects Mori PersistentHashMap support complex
                keys. It's recommended that you only use immutable
                values for your keys - numbers, strings or a Mori
                collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var m0 = mori.hash_map("foo", 1, "bar", 2);
// m0 = {"foo" 1, "bar" 2}

mori.get(m0, "bar"); // => 2

var m1 = mori.assoc(m0, m.vector(1,2), 3);
// m1 = {"foo" 1, "bar" 2, [1 2] 3}

mori.get(m1, m.vector(1,2)); // => 3
                </pre>
            </div>
            <p>
                Note that internally Mori can treat strings as functions. This
                means that Underscore.js's <code>pluck</code> is unnecessary.

                For example in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
m = mori
bob = m.hash_map "first", "Bob", "last", "Smith"
mary = m.hash_map "first", "Mary", "last", "Jane"

m.map "first", [bob, mary] // ("Bob" "Mary")
                </pre>
            </div>

            <h3 id="set">
                set
                <span class="sig">mori.set(seqable)</span>
            </h3>
            <p>
                Constructs a collection of unique items. You may pass
                in any seqable type - this includes JavaScript arrays
                and strings. There are several operations unique to
                sets which do not apply to the other collections.
            </p>
            <div class="example">
                <pre class="brush: clojure">
var s = mori.set(["bird", "cat", "dog"]);

s.conj("dog"); // => #{"bird" "cat" "dog"}
s.conj("zebra"); // => #{"bird" "cat" "dog" "zebra"}
                </pre>
            </div>
            
            <h3 id="sorted_set">
                sorted_set
                <span class="sig">mori.sorted_set(arg0, arg1, ...)</span>
            </h3>
            <p>
                Like set but keeps its elements ordered.
            </p>
            <div class="example">
                <pre class="brush: clojure">
mori.seq(mori.set([3,2,1,3])); // (1 2 3)
                </pre>
            </div>

            <h2 id="fundamentals">Fundamentals</h2>

            <h3 id="equals">
                equals
                <span class="sig">mori.equals(x, y)</span>
            </h3>
            <p>
                Test whether two values are equal. Works on all Mori collections.
                Note that two seqable values will be tested on deep equality of their
                contents.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var l0 = mori.list(1,2,3);
var l1 = mori.list(1,2,3);
mori.equals(l0, l1); // => true

var v = mori.vector(1,2,3);
mori.equals(v, l0); // => true

var m0 = mori.js_to_clj({foo: 1});
var m1 = mori.js_to_clj({foo: 1}); 
mori.equals(m0, m1); // => true
                </pre>
            </div>

            <h2 id="collection_operations">Collection Operations</h2>

            <h3 id="conj">
                conj
                <span class="sig">mori.conj(coll, arg0, arg1, ...)</span>
            </h3>
            <p>
                Add something to a collection. The behavior depends on
                the type of the collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list(2,3);
mori.conj(l, 1); // => (1 2 3)

var v = mori.vector(1,2);
mori.conj(v, 3); // => [1 2 3]

var m = mori.hash_map("foo", 1);
mori.conj(m, mori.vector("bar", 2));; // => {"foo" 1 "bar" 2}

var s = mori.set(["cat", "bird", "dog"]);
mori.conj(s, "zebra"); // => #{"cat" "bird" "dog" "zebra"}
                </pre>
            </div>

            <h3 id="assoc">
                assoc
                <span class="sig">mori.assoc(coll, key0, val0, key1, val1, ...)</span>
            </h3>
            <p>
                Associate an new key-value pair in an associative collection. Works
                on vectors and maps.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
mori.assoc(v, 1, "quux"); // => ["foo" "quux" "baz"]

var m = mori.hash_map("foo", 1);
mori.assoc(m, "bar", 2); // => {"foo" 1 "bar" 2}
mori.assoc(m, "foo", 6); // => {"foo" 6}
                </pre>
            </div>

            <h3 id="dissoc">
                dissoc
                <span class="sig">mori.dissoc(coll, key0, key1, ...)</span>
            </h3>
            <p>
                Removes keys from an associative collection. Works on maps.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var m = mori.hash_map("foo", 1, "bar", 2, "baz", 3);
mori.dissoc(m, "bar", "baz"); // => {"foo" 1}
                </pre>
            </div>

            <h3 id="get">
                get
                <span class="sig">mori.get(coll, key, [not-found])</span>
            </h3>
            <p>Retrieve a value from a collection </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
mori.get(v, 1); // "bar"

var m = mori.hash_map("foo", 1, "bar", 2);
mori.get(m, "foo"); // => 1
mori.get(m, "baz", "nope"); // => "nope"

                </pre>
            </div>

            <h3 id="get_in">
                get_in
                <span class="sig">mori.get_in(coll, keys, [not-found])</span>
            </h3>
            <p>
                Retrieve a value from a nested collection. <code>keys</code> may be any seqable object.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
var v2 = mori.vector("quux", v);
mori.get_in(v2, [1, 2]); // => "baz"

var m = mori.hash_map("foo", 1, "bar", 2);
var m2 = mori.hash_map("baz", 3, "quux", m);
mori.get_in(m2, ["quux", "bar"]); // => 2
                </pre>
            </div>

            <h3 id="has_key">
                has_key
                <span class="sig">mori.has_key(coll, key)</span>
            </h3>
            <p> Returns true if the collection has the given key/index. Otherwise, returns false </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
mori.has_key(v, 1); // => true
mori.has_key(v, 9); // => false

var m = mori.hash_map("foo", 1, "bar", 2);
mori.has_key(m, "foo"); // => true
mori.has_key(m, "quux"); // => false

var s = mori.set(["foo", "bar", "baz"]);
mori.has_key(s, 1); // => true
mori.has_key(s, 9); // => false
                </pre>
            </div>

            <h3 id="find">
                find
                <span class="sig">mori.find(coll, key)</span>
            </h3>
            <p>
                Returns the key value pair as an array for a given key. Return's null if that key isn't present.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz")
mori.find(v, 2) // => [2, "baz"]
mori.find(v, 9) // null

var m = mori.hash_map("foo", 1, "bar", 2)
mori.find(m, "foo") // => ["foo", 1]
mori.find(m, "quux") // null
                </pre>
            </div>

            <h3 id="nth">
                nth
                <span class="sig">mori.nth(coll, index)</span>
            </h3>
            <p>
                Get the value at the specified index. Complexity
                depends on the collection. <code>nth</code> is essentially
                constant on vector, but linear on lists. For collections
                which are not sequential like sets and hash-map, the
                collection will be coerced into a sequence first.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var h = mori.hash_map("foo", mori.hash_map("bar", 1)]);
mori.assoc_in(h, ["foo", "baz"], 2); // => {"foo" {"bar" 1, "baz" 2}}
                </pre>
            </div>

            <h3 id="assoc_in">
                assoc_in
                <span class="sig">mori.assoc_in(coll, keys, val)</span>
            </h3>
            <p>
                Convenience function for assoc'ing nested associative
                data structures. <code>keys</code> may be any seqable.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var h = mori.hash_map("foo", mori.hash_map("bar", 1)]);
mori.assoc_in(h, ["foo", "baz"], 2); // => {"foo" {"bar" 1, "baz" 2}}
                </pre>
            </div>

            <h3 id="update_in">
                update_in
                <span class="sig">mori.update_in(coll, keys, function)</span>
            </h3>
            <div class="example">
                <pre class="brush: javascript">
var h = mori.hash_map("foo", mori.vector(1, 2, 3)]);
mori.update_in(h, ["foo", 1], mori.inc); // => {"foo" [1 3 3]}
                </pre>
            </div>

            <h3 id="count">
                count
                <span class="sig">mori.count(coll)</span>
            </h3>
            <p> Returns the length of the collection </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list("foo", "bar", "baz")
mori.count(l) // 3

var v = mori.vector("foo", "bar", "baz")
mori.count(v) // 3

var s = mori.set(["foo", "bar", "baz"])
mori.count(s) // 3

var m = mori.hash_map("foo", 1, "bar", 2)
mori.count(m) // 2
                </pre>
            </div>

            <h3 id="peek">
                peek
                <span class="sig">mori.peek(coll)</span>
            </h3>
            <p> Returns either the first item of a list or the last item of a vector </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list("foo", "bar", "baz")
mori.peek(l) // "foo"

var v = mori.vector("foo", "bar", "baz")
mori.peek(v) // "baz"
                </pre>
            </div>

            <h3 id="pop">
                pop
                <span class="sig">mori.pop(coll)</span>
            </h3>
            <p> Returns either a list with the first item removed or a vector with the last item removed </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list("foo", "bar", "baz")
mori.pop(l) // ("bar" "baz")

var v = mori.vector("foo", "bar", "baz")
mori.pop(v) // ["foo" "bar"]
                </pre>
            </div>

            <h3 id="zipmap">
                zipmap
                <span class="sig">mori.zipmap(seqable0, seqable1)</span>
            </h3>
            <p>
                Takes two seqable objects and constructs a hash map. The first seqable provides the keys
                the second seqable the values.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var keys = ["foo", "bar", "baz"];
var vals = [1, 2, 3];

var h = mori.zipmap(keys, vals); // => {"foo" 1, "bar" 2, "baz" 3}
                </pre>
            </div>


            <h2 id="collection_operations">Vector Operations</h2>
            <h3 id="subvec">
                subvec
                <span class="sig">mori.subvec(vector, start, [end])</span>
            </h3>
            <p>
                Returns a subsection of a vector in constant time.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s = mori.vector("cat", "dog", "bird", "zebra");
s.subvec(1,2); // => ["dog", "bird"]
                </pre>
            </div>


            <h2 id="collection_operations">Set Operations</h2>

            <h3 id="disj">
                disj
                <span class="sig">mori.disj(set)</span>
            </h3>
            <p>
                Removes an element from a set.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s = mori.set(["cat", "dog", "bird"]); // => #{"cat" "bird" "dog"}
s.disj("bird"); // => #{"dog" "cat"}
                </pre>
            </div>

            <h3 id="union">
                union
                <span class="sig">mori.union(set0, set1, ...)</span>
            </h3>
            <p>
                Returns the union of two sets.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s0 = mori.set(["cat", "dog"]);
var s1 = mori.set(["zebra", "lion"]);

mori.union(s0, s1); // => #{"lion" "cat" "dog" "zebra"}
                </pre>
            </div>

            <h3 id="intersection">
                intersection
                <span class="sig">mori.intersection(set0, set1, ...)</span>
            </h3>
            <p>
                Returns the intersection of two sets.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s0 = mori.set(["cat", "dog", "mouse"]);
var s1 = mori.set(["dog", "cat", "bird"]);

mori.intersection(s0, s1); // => #{"cat" "dog"}
                </pre>
            </div>

            <h3 id="difference">
                difference
                <span class="sig">mori.difference(set0, set1, ...)</span>
            </h3>
            <p>
                Returns the difference of two sets.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s0 = mori.set(["cat", "dog", "mouse"]);
var s1 = mori.set(["dog", "cat", "bird"]);

mori.difference(s0, s1); // => #{"mouse" "bird"}
                </pre>
            </div>

            <h3 id="is_subset">
                is_subset
                <span class="sig">mori.is_subset(seta, setb)</span>
            </h3>
            <p>
                Returns true if <code>seta</code> is a subset of <code>setb</code>.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s0 = mori.set(["dog", "cat"]);
var s1 = mori.set(["cat", "dog", "bird"]);

mori.is_subset(s0, s1); // => true
                </pre>
            </div>

            <h3 id="is_superset">
                is_superset
                <span class="sig">mori.is_superset(seta, setb)</span>
            </h3>
            <p>
                Returns true if <code>seta</code> is a supset of <code>setb</code>.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var s0 = mori.set(["cat", "dog", "bird"]);
var s1 = mori.set(["dog", "cat"]);

mori.is_superset(s0, s1); // => true
                </pre>
            </div>


            <h2 id="sequences">Sequences</h2>
            
            <h3 id="first">
                first
                <span class="sig">mori.first(coll)</span>
            </h3>
            <p>
                Returns the first element in a collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.first("foobar"); // => "f"

mori.first([1,2,3]); // => 1

var l = mori.list(1,2,3);
mori.first(l); // => 1

var m = mori.hash_map("foo", 1, "bar", 2);
mori.first(m); // some key-value pair as an array
                </pre>
            </div>

            <h3 id="rest">
                rest
                <span class="sig">mori.rest(coll)</span>
            </h3>
            <p>
                Returns the remaining elements in a collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.rest("foobar"); // => ("o" "o" "b" "a" "r")

mori.rest([1,2,3]); // => (2 3)

var l = mori.list(1,2,3);
mori.rest(l); // => (2 3)

var m = mori.hash_map("foo", 1, "bar", 2);
mori.rest(m); // remaining key-value pairs
                </pre>
            </div>
            
            <h3 id="seq">
                seq
                <span class="sig">mori.seq(coll)</span>
            </h3>
            <p>
                Converts a collection whether Mori or JavaScript primitive
                into a sequence.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.seq("foo"); // => ("f" "o" "o")
mori.seq(mori.list()); // => null
                </pre>
            </div>

            <h3 id="into_array">
                into_array
                <span class="sig">mori.into_array(seq)</span>
            </h3>
            <p>
                Converts a seqable collection, including Mori seqs back into a JavaScript array. Non-lazy.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var lazy = mori.map(mori.inc, [1,2,3]);
mori.into_array(lazy); // => [2,3,4]
                </pre>
            </div>


            <h3 id="each">
                each
                <span class="sig">mori.each(coll)</span>
            </h3>
            <p>
                Iterate over a collection. For side effects.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var xs = mori.map(mori.inc, [1,2,3]);
mori.each(xs, function(n) {
  console.log(n);
});

// will print 1 then 2 then 3 at your JS console
                </pre>
            </div>

            <h3 id="map">
                map
                <span class="sig">mori.map(f, coll0, coll1, ...)</span>
            </h3>
            <p>
                Return a lazy sequence representing that represents
                the original collection with <code>f</code> applied to
                each element. Note that map can take multiple collections
                This obviates the need for Underscore.js's zip.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a0 = [1,2,3];

mori.map(mori.inc, a0); // => (2 3 4)

var a1 = [4,5,6];
var a2 = [7,8,9];

mori.map(mori.vector, a0, a1, a2); // => ([1 4 7] [2 5 8] [3 6 9])
                </pre>
            </div>

            <h3 id="filter">
                filter
                <span class="sig">mori.filter(pred, coll)</span>
            </h3>
            <p>
                Return a lazy sequence representing with the original
                collection filtered of elements which did not return a truthy
                value for <code>pred</code>. Note that Mori has a stricter
                notion of truth than JavaScript. Only false, undefined, and null
                are considered false values.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a = [0,1,2,3,4,5,7,7,9];

mori.filter(mori.is_even, a0); // => (0 2 4 6 8)
                </pre>
            </div>

            <h3 id="remove">
                remove
                <span class="sig">mori.remove(pred, coll)</span>
            </h3>
            <p>
                The inverse of filter. Return a lazy sequence representing with the original
                collction filtered of elements which returned a truthy
                value for <code>pred</code>. Note that Mori has a stricter
                notion of truth than JavaScript. Only false, undefined, and null
                are considered false values.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a = [0,1,2,3,4,5,6,7,9];

mori.remove(mori.is_even, a0); // => (1 3 5 7 9)
                </pre>
            </div>


            <h3 id="reduce">
                reduce
                <span class="sig">mori.reduce(f, [intial], coll)</span>
            </h3>
            <p>
                Accumulate a collection into a single value. <code>f</code>
                should be a function of two arguments, the first will be the
                accumulator the second will be next value in the sequence.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a = mori.range(10);

mori.reduce(mori.sum, 0, r); // => 45
                </pre>
            </div>

            <h3 id="take">
                take
                <span class="sig">mori.take(n, coll)</span>
            </h3>
            <p>
                Takes n elements from a colletion. Note that <code>coll</code>
                could be an infinite sequence. This function returns
                a lazy sequence.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a = mori.range(); // infinite sequence

mori.take(10, r); // => (0 1 2 3 4 5 6 7 8 9)
                </pre>
            </div>
            
            <h3 id="take_while">
                take_while
                <span class="sig">mori.take_while(pred, coll)</span>
            </h3>
            <p>
                Takes elements from a collection while the pred returns
                true. Returns a lazy sequence.
            </p>
            <p>
                The following example is in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
a = [0,1,2,3,4,5,6,7,8,9]
mori.take_while ((n) -> n < 5), r // => (0 1 2 3 4)
                </pre>
            </div>

            <h3 id="drop">
                drop
                <span class="sig">mori.drop(n, coll)</span>
            </h3>
            <p>
                Drop n elements from a collection. Returns
                a lazy sequence.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a = [0,1,2,3,4,5,6,7,8,9]
mori.drop(5, a); // => (5 6 7 8 9)
                </pre>
            </div>


            <h3 id="drop_while">
                drop_while
                <span class="sig">mori.interleave(pred, coll)</span>
            </h3>
            <p>
                Drop elements from a collection as long as <code>pred</code>
                return true. Returns a lazy sequence.
            </p>
            <p>
                The following example is in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
a = [0,1,2,3,4,5,6,7,8,9]

mori.drop_while ((n) -> n<5), a // => (5 6 7 8 9)
                </pre>
            </div>

            <h3 id="interpose">
                interpose
                <span class="sig">mori.interpose(x, coll)</span>
            </h3>
            <p>
                Interpose a value between all elements of a collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var a = [1,2,3]

mori.interpose("foo", a) // => (1 "foo" 2 "foo" 3)
                </pre>
            </div>
            
            <h3 id="interleave">
                interleave
                <span class="sig">mori.interleave(coll0, coll1, ...)</span>
            </h3>
            <p>
                Interleave two or more collections. The size the resulting
                lazy sequence is determined by the smalled collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var ns = [1,2,3];
var as = ["a", "b", "c"];

mori.interleave(ns, as); // => (1 "a" 2 "b" 3 "c")
                </pre>
            </div>
            
            <h3 id="iterate">
                iterate
                <span class="sig">mori.iterate(f, x)</span>
            </h3>
            <p>
                Creats a lazy sequences of x, f(x), f(f(x)), ...
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.iterate(mor.inc, 0); // => (0 1 2 3 4 5 ...)
                </pre>
            </div>
            
            <h3 id="repeat">
                repeat
                <span class="sig">mori.repeat([n], x)</span>
            </h3>
            <p>
                Return a lazy of sequence of the value repeated.
                If given <code>n</code>, the value will only be
                repeated n times.
            </p>
            <p>
                The following example is in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
m    = mori
foos = m.repeat("foo")

m.zipmap [1,2,3], foos // => {1 "foo", 2 "foo", 3 "foo"}
                </pre>
            </div>
            
            <h3 id="repeatedly">
                repeatedly
                <span class="sig">mori.repeatedly([n], f)</span>
            </h3>
            <p>
                Return a lazy of sequence of calling <code>f</code>, a
                function which takes no arguments (presumably for side effects).
                If given <code>n</code>, the function will only be
                repeated n times.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.repeatedly(5, #(.random js/Math));
// => (... 5 random floating point numbers ...)
                </pre>
            </div>
            
            
            <h3 id="partition">
                partition
                <span class="sig">mori.partition(n, [step], [pad], coll)</span>
            </h3>
            <p>
                Partition a seqable collection into a groups of n items. An optional step
                parameter may be provided to specify the amount of overlap. Additional a pad
                element can be provided when the final group of items is too small.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var m   = mori,
    arr = [0,1,2,3,4,5,6,7,8,9],
    ps  = m.partition(2, arr);

m.into_array(m.map(m.into_array, ps));
// => [[0,1],[2,3],[4,5],[6,7],[8,9]]

ps = m.partition(2, 1, arr);
m.into_array(m.map(m.into_array, ps));
// => [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9]]
                </pre>
            </div>

            <h3 id="group_by">
                group_by
                <span class="sig">mori.group_by(f, coll)</span>
            </h3>
            <p>
                Returns a map of the items grouped by the result of applying
                <code>f</code> to the element.
            </p>
            <div class="example">
                <pre class="brush: javascript">
function even_odd(n) {
  return mori.is_even(n) ? "even" : "odd";
}

var r = mori.range(10);
mori.group_by(even_odd, r); // => {"even" (0 2 4 6 8) "odd" (1 3 5 7 9)}
                </pre>
            </div>

            <!--
            <h2 id="reducers">Reducer Framework</h2>
            <h3 id="rmap">rmap</h3>
            <h3 id="rfilter">rfilter</h3>
            <h3 id="rtake">rtake</h3>
            <h3 id="rdrop">rdrop</h3>
            -->

            <h2 id="helpers">Helpers</h2>

            <h3 id="prim_seq">
                prim_seq
                <span class="sig">mori.prim_seq(seqable, [index])</span>
            </h3>
            <p>
                There are many array-like JavaScript objects which
                are not actually arrays. To give these objects a uniform
                interface you can wrap them with <code>mori.prim_seq</code>.
                The optional argument <code>index</code> may be used to
                specify an offset. Note this is not necesary for arrays or
                strings.
            </p>
            <div class="example">
                <pre class="brush: javascript">
function foo() {
  var args = mori.prim_seq(arguments);
  var f = mori.first(args);
}
                </pre>
            </div>

            <h3 id="identity">
                identity
                <span class="sig">mori.identity(x)</span>
            </h3>
            <p>A function which simply returns its argument</p>
            <div class="example">
                <pre class="brush: javascript">
mori.identity(5); // => 5
                </pre>
            </div>

            <h3 id="inc">
                inc
                <span class="sig">mori.inc(n)</span>
            </h3>
            <p>
                Adds one to its argument.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.inc(1); // => 2</pre>
            </div>

            <h3 id="dec">
                dec
                <span class="sig">mori.dec(n)</span>
            </h3>
            <p>
                Subtracts one from its argument.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.dec(1); // => 0</pre>
            </div>

            <h3 id="sum">
                sum
                <span class="sig">mori.sum(a, b)</span>
            </h3>
            <p>
                Add its two arguments together. Useful with <code>mori.reduce</code>.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.sum(1,2); // => 3

mori.reduce(mori.sum, 0, mori.range(10)); // 45</pre>
            </div>
            
            <h3 id="is_even">
                is_even
                <span class="sig">mori.is_even(n)</span>
            </h3>
            <p>
                Returns true if the argument is divisible by 2.
            </p>
            
            <h3 id="is_odd">
                is_odd
                <span class="sig">mori.is_odd(n)</span>
            </h3>
            <p>
                Returns true if the argument is not divisible by 2.
            </p>

            <h3 id="juxt">
                juxt
                <span class="sig">mori.juxt(f0, f1, ...)</span>
            </h3>
            <p>
                Takes a series of functions and creates a single function
                which represents their "juxtaposition". When this function
                is called, will return the result of each function applied
                to the arguments in a JavaScript array.
            </p>
            <p>
                The following example is in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
f = mori.juxt "last", "first"
p = mori.hash_map "first", "Bob", "last", "Smith"

f(p).join ", " // => "Smith, Bob"
                </pre>
            </div>

            <h3 id="knit">
                knit 
                <span class="sig">mori.knit(f0, f1, ...)</span>
            </h3>
            <p>
                This allows you to create functions that work on a heterogenous
                collection and return a new collecton of the same
                arity. It is an relative
                of <a href="#juxt"><code>juxt</code></a>. Like <code>juxt</code>
                it takes a series of functions and returns a new
                function. Unlike <code>juxt</code> the resulting
                function takes a sequence. The functions and sequence
                are zipped together and invoked.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var f = mori.knit(function (s) { return s.toLowerCase(); }, 
                  function (s) { return s.toUpperCase(); });
f(["FoO", "bAr"]); // => ["foo", "BAR"]
                </pre>
            </div>

            <h3 id="pipeline">
                pipeline
                <span class="sig">mori.knit(x, f0, f1, ...)</span>
            </h3>
            <p>
                Allows threading a value through a series of functions.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var _ = mori;

_.pipeline(
  _.vector(1,2,3),
  _.curry(_.conj, 4),
  _.curre(_.conj, 5)
); // => [1,2,3,4,5]
                </pre>
            </div>

            <h3 id="partial">
                partial
                <span class="sig">mori.partial(f, x, y, ...)</span>
            </h3>
            <p>
                Partial application. Will return a new function in which
                the provided arguments have been partially applied.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var _ = mori;
var f = _.partial(_.conj, _.vector(1,2,3));

f(4); // => [1,2,3,4]
f(5); // => [1,2,3,5]
                </pre>
            </div>

            <h3 id="curry">
                curry
                <span class="sig">mori.curry(f, x, y, ...)</span>
            </h3>
            <p>
                Curry arguments to a function.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var _ = mori;
    f = _.curry(_.conj, 4);

f(_.vector(1,2,3)); // => [1,2,3,4]
                </pre>
            </div>

            <h3 id="fnil">
                fnil
                <span class="sig">mori.fnil(f, x, y, ...)</span>
            </h3>
            <p>
                Takes a function f and returns a new function that upon
                receiving an argument, if null, will be replaced with x. fnil
                may take up to three arguments.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var _ = mori;
var f = function(x) {
  return _.update_in(x, ["count"], _.fnil(_.inc, 0));
};

f(_.hash_map()); // => {"count", 1}
                </pre>
            </div>

        </div>
        <script>
            SyntaxHighlighter.defaults["gutter"] = false;
            SyntaxHighlighter.all();
        </script>
    </body>
</html>
