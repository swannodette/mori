<html>
    <head>
        <script type="text/javascript" src="js/xregexp-min.js"></script>
        <script type="text/javascript" src="js/shCore.js"></script>
        <script type="text/javascript" src="js/shBrushClojure.js"></script>
        <script type="text/javascript" src="js/shBrushJScript.js"></script>
        <link rel="stylesheet" type="text/css" href="css/base.css" />
        <link rel="stylesheet" type="text/css" href="css/shCore.css" />
        <link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
        <script type="text/javascript" src="http://use.typekit.com/rvk4jgw.js"></script>
        <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    </head>
    <body>

        <div id="mori-nav">

            <a href="#mori" class="toc-title">Mori</a>
            <br/>

            <a href="#rationale" class="toc-title">Rationale</a>
            <ul>
               <li><a href="#island">- Mori is not an island</a></li>
                <li><a href="#usage">- Using Mori</a></li>
                <li><a href="#notation">- Notation</a></li>
            </ul>

            <a href="#collection" class="toc-title">Collections</a>
            <ul>
                <li><a href="#list">- list</a></li>
                <li><a href="#vector">- vector</a></li>
                <li><a href="#hash_map">- hash_map</a></li>
                <li><a href="#set">- set</a></li>
                <li><a href="#sorted_set">- sorted_set</a></li>
            </ul>

            <a class="toc-title">Collection Operations</a>
            <ul>
                <li><a href="#conj">- conj</a></li>
                <li><a href="#assoc">- assoc</a></li>
                <li><a href="#dissoc">- dissoc</a></li>
                <li><a href="#get">- get</a></li>
                <li><a href="#get_in">- get_in</a></li>
                <li><a href="#has_key">- has_key</a></li>
                <li><a href="#find">- find</a></li>
                <li><a href="#nth">- nth</a></li>
                <li><a href="#assoc_in">- assoc_in</a></li>
                <li><a href="#update_in">- update_in</a></li>
                <li><a href="#count">- count</a></li>
                <li><a href="#peek">- peek</a></li>
                <li><a href="#pop">- pop</a></li>
                <li><a href="#pop">- zipmap</a></li>
            </ul>

            <a class="toc-title">Set Operations</a>
            <ul>
                <li><a href="#union">- union</a></li>
                <li><a href="#intersection">- intersection</a></li>
                <li><a href="#difference">- difference</a></li>
                <li><a href="#is_subset">- is_subset</a></li>
                <li><a href="#is_superset">- is_superset</a></li>
            </ul>

            <a class="toc-title">Sequences</a>
            <ul>
                <li><a href="#first">- first</a></li>
                <li><a href="#rest">- rest</a></li>
                <li><a href="#seq">- seq</a></li>
                <li><a href="#seq">- each</a></li>
                <li><a href="#map">- map</a></li>
                <li><a href="#filter">- filter</a></li>
                <li><a href="#remove">- remove</a></li>
                <li><a href="#reduce">- reduce</a></li>
                <li><a href="#take">- take</a></li>
                <li><a href="#take_while">- take_while</a></li>
                <li><a href="#drop">- drop</a></li>
                <li><a href="#drop_while">- drop_while</a></li>
                <li><a href="#interpose">- interpose</a></li>
                <li><a href="#interleave">- interleave</a></li>
                <li><a href="#repeat">- repeat</a></li>
                <li><a href="#repeatedly">- repeatedly</a></li>
                <li><a href="#partition">- partition</a></li>
                <li><a href="#group_by">- group_by</a></li>
            </ul>

            <a class="toc-title">Helpers</a>
            <ul>
                <li><a href="#prim_seq">- prim_seq</a></li>
                <li><a href="#identity">- identity</a></li>
                <li><a href="#sum">- sum</a></li>
                <li><a href="#inc">- inc</a></li>
                <li><a href="#dec">- dec</a></li>
                <li><a href="#is_even">- is_even</a></li>
                <li><a href="#is_odd">- is_odd</a></li>
                <li><a href="#juxt">- juxt</a></li>
                <li><a href="#knit">- knit</a></li>
                <li><a href="#pipeline">- pipeline</a></li>
                <li><a href="#partial">- partial</a></li>
                <li><a href="#curry">- curry</a></li>
                <li><a href="#curry">- fnil</a></li>
            </ul>

            <a class="toc-title">Zippers</a>
        </div>

        <div id="mori-content">
            <h1 id="mori" class="tk-anisette-petite">mori</h1>

            <p>
                A library for using ClojureScript's persistent data
                structures and supporting API from the comfort of
                vanilla JavaScript.
            </p>

            <h2 id="rationale">Rationale</h2>
            <p>
                JavaScript is a powerful and flexible dynamic
                programming language with a beautiful simple
                associative model at its core. However this design
                comes at the cost of ubiquitous mutability. Mori
                embraces the simple associative model but leaves
                mutability behind. Mori delivers the following
                benefits to JavaScript:
            </p>
            <ul>
                <li>Efficient immutable data structures - no cloning required</li>
                <li>Uniform iteration for all types</li>
                <li>Value based equality</li>
            </ul>
            <p>
                Modern JavaScript engines like V8, JavaScriptCore, and
                SpiderMonkey deliver the performance needed to implement
                peristent data structures well.
            </p>

            <h3 id="island">Mori is not an island</h3>
            <p>
                Beyond the the core philosophy Mori makes no other
                assumptions about how you might use it. In fact, Mori
                has changed some aspects of the ClojureScript API in
                order to better accomodate usage from JavaScript and
                languages that target JavaScript like
                CoffeeScript. For example, where it makes sense, Mori
                returns regular JavaScript arrays so that you can use
                destructuring syntax where available.

                The following example is in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
m = mori;
[a, b] = m.juxt(m.inc, m.dec)(1); // a = 2, b = 0
                </pre>
            </div>


            <h3 id="usage">Using Mori</h3>
            <p>
                Mori can be used in precisely the same way that
                libraries like Underscore.js are used. Mori of course
                provides not only the same functionality but it
                delivers a rich set of data structures.
                Mori's operators are more general than the ones
                provided by Underscore.js - they work on nearly all
                the native JavaScript types. In those cases where they
                do not work you usually just need to wrap the type
                in <code>mori.prim_seq(...)</code>.
            </p>

            <h3 id="notation">Notation</h3>
            <p>
                Each entry is annotated with the signature with an accompanying
                description and some relevant examples. Optional parameters appear
                as <code>[option]</code> in thhe signature. Sometimes the signature
                or description will mention <em>seqable</em>. This simply means
                any type that can be coerced into a sequence. This include all
                Mori collections as well as JavaScript Arrays and Strings.
            </p>
            <p>
                All the examples are in JavaScript or CoffeeScript. However,
                for simplicity's sake we show the <i>results</i> of operations
                in Clojure literal syntax notation.
            </p>
            <div class="example">
                <pre class="brush: clojure">
(1 2 3 4)              ;; list

[1 2 3 4]              ;; vector

{"foo" 1, "bar" 2}      ;; hash map

#{"cat" "bird" "dog"}  ;; set / sorted-set
                </pre>
            </div>

            <h2 id="collections">Collections</h2>

            <h3 id="list">
                list
                <span class="sig">mori.list(arg0, arg1, ...)</span>
            </h3>
            <p>
                Constructs an immutable list. Lists support efficient
                addition at the head of the list. It's important to
                remember that the cost of operations like
                <code>mori.nth</code> will be linear in the size of
                the list.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list(2,3);

mori.cons(l, 1); // => (1 2 3)
                </pre>
            </div>
                
            <h3 id="vector">
                vector
                <span class="sig">mori.vector(arg0, arg1, ...)</span>
            </h3>
            <p>
                Constructs an immutable vector. Vectors support efficient
                addition at the end. They also support efficient random
                access. You will probaly use <code>mori.vector</code> much
                more often than <code>mori.list</code>
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector(1,2,3,4);
mori.nth(v, 0); // => 1
                </pre>
            </div>
            
            <h3 id="hash_map">
                hash_map
                <span class="sig">mori.hash_map(key0, val0, key1, val1, ...)</span>
            </h3>
            <p>
                Constructs an immutable hash map. Unlike JavaScript
                objects Mori PersistentHashMap support complex
                keys. It's recommended that you only use immutable
                values for your keys - numbers, strings or a Mori
                collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var m0 = mori.hash_map("foo", 1, "bar", 2);
// m0 = {"foo" 1, "bar" 2}

mori.get(m0, "bar"); // => 2

var m1 = mori.assoc(m0, m.vector(1,2), 3);
// m1 = {"foo" 1, "bar" 2, [1 2] 3}

mori.get(m1, m.vector(1,2)); // => 3
                </pre>
            </div>
            <p>
                Note that internally Mori can treat strings as functions. This
                means that Underscore.js's <code>pluck</code> is unnecessary.

                For example in CoffeeScript:
            </p>
            <div class="example">
                <pre class="brush: javascript">
m = mori
bob = m.hash_map "first", "Bob", "last", "Smith"
mary = m.hash_map "first", "Mary", "last", "Jane"

m.map "first", [bob, mary] // ("Bob" "Mary")
                </pre>
            </div>

            <h3 id="set">
                set
                <span class="sig">mori.set(seqable)</span>
            </h3>
            <p>
                Constructs a collection of unique items. You may pass
                in any seqable type - this includes JavaScript arrays
                and strings. There are several operations unique to
                sets which do not apply to the other collections.
            </p>
            <div class="example">
                <pre class="brush: clojure">
var s = mori.set(["bird", "cat", "dog"]);

s.conj("dog"); // => #{"bird" "cat" "dog"}
s.conj("zebra"); // => #{"bird" "cat" "dog" "zebra"}
                </pre>
            </div>
            
            <h3 id="sorted_set">
                sorted_set
                <span class="sig">mori.sorted_set(arg0, arg1, ...)</span>
            </h3>
            <p>
                Like set but keeps its elements ordered.
            </p>
            <div class="example">
                <pre class="brush: clojure">
mori.seq(mori.set([3,2,1,3])); // (1 2 3)
                </pre>
            </div>

            <h2 id="collection_operations">Collection Operations</h2>

            <h3 id="conj">
                conj
                <span class="sig">mori.conj(coll, arg0, arg1, ...)</span>
            </h3>
            <p>
                Add something to a collection. The behavior depends on
                the type of the collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list(2,3);
mori.conj(l, 1); // => (1 2 3)

var v = mori.vector(1,2);
mori.conj(v, 3); // => [1 2 3]

var m = mori.hash_map("foo", 1);
mori.conj(m, mori.vector("bar", 2));; // => {"foo" 1 "bar" 2}

var s = mori.set(["cat", "bird", "dog"]);
mori.conj(s, "zebra"); // => #{"cat" "bird" "dog" "zebra"}
                </pre>
            </div>

            <h3 id="assoc">
                assoc
                <span class="sig">mori.assoc(coll, key0, val0, key1, val1, ...)</span>
            </h3>
            <p>
                Associate an new key-value pair in an associative collection. Works
                on vectors and maps.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
mori.assoc(v, 1, "quux"); // => ["foo" "quux" "baz"]

var m = mori.hash_map("foo", 1);
mori.assoc(m, "bar", 2); // => {"foo" 1 "bar" 2}
mori.assoc(m, "foo", 6); // => {"foo" 6}
                </pre>
            </div>

            <h3 id="get">
                get
                <span class="sig">mori.get(coll, key, [not-found])</span>
            </h3>
            <p>Retrieve a value from a collection </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
mori.get(v, 1); // "bar"

var m = mori.hash_map("foo", 1, "bar", 2);
mori.get(m, "foo"); // => 1
mori.get(m, "baz", "nope"); // => "nope"

                </pre>
            </div>

            <h3 id="get_in">
                get_in
                <span class="sig">mori.get_in(coll, keys, [not-found])</span>
            </h3>
            <p>
                Retrieve a value from a nested collection. <code>keys</code> may be any seqable object.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
var v2 = mori.vector("quux", v);
mori.get_in(v2, [1, 2]); // => "baz"

var m = mori.hash_map("foo", 1, "bar", 2);
var m2 = mori.hash_map("baz", 3, "quux", m);
mori.get_in(m2, ["quux", "bar"]); // => 2
                </pre>
            </div>

            <h3 id="has_key">has_key</h3>
            <p> Returns true if the collection has the given key/index. Otherwise, returns false </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz");
mori.has_key(v, 1); // => true
mori.has_key(v, 9); // => false

var m = mori.hash_map("foo", 1, "bar", 2);
mori.has_key(m, "foo"); // => true
mori.has_key(m, "quux"); // => false

var s = mori.set(["foo", "bar", "baz"]);
mori.has_key(s, 1); // => true
mori.has_key(s, 9); // => false
                </pre>
            </div>

            <h3 id="find">find</h3>
            <p> Returns the key value pair for a given key. Return's null if that key isn't present </p>
            <div class="example">
                <pre class="brush: javascript">
var v = mori.vector("foo", "bar", "baz")
mori.find(v, 2) // [2 "baz"]
mori.find(v, 9) // null

var m = mori.hash_map("foo", 1, "bar", 2)
mori.find(m, "foo") // [ "foo" 1 ]
mori.find(m, "quux") // null
                </pre>
            </div>

            <h3 id="nth">
                nth
            </h3>

            <h3 id="assoc_in">
                assoc_in
            </h3>

            <h3 id="update_in">
                update_in
            </h3>

            <h3 id="count">
                count
            </h3>
            <p> Returns the length of the collection </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list("foo", "bar", "baz")
mori.count(l) // 3

var v = mori.vector("foo", "bar", "baz")
mori.count(v) // 3

var s = mori.set(["foo", "bar", "baz"])
mori.count(s) // 3

var m = mori.hash_map("foo", 1, "bar", 2)
mori.count(m) // 2
                </pre>
            </div>

            <h3 id="peek">peek</h3>
            <p> Returns either the first item of a list or the last item of a vector </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list("foo", "bar", "baz")
mori.peek(l) // "foo"

var v = mori.vector("foo", "bar", "baz")
mori.peek(v) // "baz"
                </pre>
            </div>

            <h3 id="pop">pop</h3>
            <p> Returns either a list with the first item removed or a vector with the last item removed </p>
            <div class="example">
                <pre class="brush: javascript">
var l = mori.list("foo", "bar", "baz")
mori.pop(l) // ("bar" "baz")

var v = mori.vector("foo", "bar", "baz")
mori.pop(v) // ["foo" "bar"]
                </pre>
            </div>

            <h3 id="zipmap">
                zipmap
                <span class="sig">mori.zipmap(seqable0, seqable1)</span>
            </h3>
            <p>
                Takes two seqable objects and constructs a hash map. The first seqable provides the keys
                the second seqable the values.
            </p>
            <div class="example">
                <pre class="brush: javascript">
var keys = ["foo", "bar", "baz"];
var vals = [1, 2, 3];

var h = mori.zipmap(keys, vals); // => {"foo" 1, "bar" 2, "baz" 3}
                </pre>
            </div>

            <h2 id="sequences">Sequences</h2>

            <h3 id="first">first</h3>
            <p>
                Returns the first element in a collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.first("foobar"); // => "f"

mori.first([1,2,3]); // => 1

var l = mori.list(1,2,3);
mori.first(l); // => 1

var m = mori.hash_map("foo", 1, "bar", 2);
mori.first(m); // some key-value pair as an array
                </pre>
            </div>

            <h3 id="rest">rest</h3>
            <p>
                Returns the remaining elements in a collection.
            </p>
            <div class="example">
                <pre class="brush: javascript">
mori.rest("foobar"); // => ("o" "o" "b" "a" "r")

mori.rest([1,2,3]); // => (2 3)

var l = mori.list(1,2,3);
mori.rest(l); // => (2 3)

var m = mori.hash_map("foo", 1, "bar", 2);
mori.rest(m); // remaining key-value pairs
                </pre>
            </div>
            
            <h3 id="seq">seq</h3>
            <h3 id="each">each</h3>
            <h3 id="map">map</h3>
            <h3 id="filter">filter</h3>
            <h3 id="remove">remove</h3>
            <h3 id="reduce">reduce</h3>
            <h3 id="take">take</h3>
            <h3 id="take_while">take_while</h3>
            <h3 id="drop">drop</h3>
            <h3 id="drop_while">drop_while</h3>
            <h3 id="interpose">interpose</h3>
            <h3 id="interleave">interleave</h3>
            <h3 id="iterate">iterate</h3>
            <h3 id="repeat">repeat</h3>
            <h3 id="repeatedly">repeatedly</h3>
            <h3 id="partition">partition</h3>
            <h3 id="group_by">group_by</h3>

            <h2 id="reducers">Reducer Framework</h2>
            <h3 id="rmap">rmap</h3>
            <h3 id="rfilter">rfilter</h3>
            <h3 id="rtake">rtake</h3>
            <h3 id="rdrop">rdrop</h3>

            <h2 id="helpers">Helpers</h2>

            <h3 id="prim_seq">prim_seq</h3>
            <p>
                There are many array-like JavaScript objects which
                are not actually arrays. To give these objects a uniform
                interface you can wrap them with <code>mori.prim_seq</code>.
            </p>
            <div class="example">
                <pre class="brush: javascript">
function foo() {
  var args = mori.prim_seq(arguments);
  var f = mori.first(args);
}
                </pre>
            </div>

            <h3 id="identity">identity</h3>
            <p>A function which simply returns its argument</p>
            <div class="example">
                <pre class="brush: javascript">
mori.identity(5); // => 5
                </pre>
            </div>

            <h3 id="inc">inc</h3>
            <p>
                Adds one to its argument.
            </p>
            <div class="example">
                <pre cass="brush: javascript">
mori.inc(1); // => 2
                </pre>
            </div>

            <h3 id="dec">dec</h3>
            <p>
                Subtracts one from its argument.
            </p>
            <div class="example">
                <pre cass="brush: javascript">
mori.dec(1); // => 0
                </pre>
            </div>

            <h3 id="sum">sum</h3>
            <p>
                Add it's two arguments together. Useful with <code>mori.reduce</code>.
            </p>
            <div class="example">
                <pre cass="brush: javascript">
mori.sum(1,2); // => 3

mori.reduce(mori.sum, 0, mori.range(10)); // 45
                </pre>
            </div>
            
            <h3 id="is_even">is_even</h3>
            <h3 id="is_odd">is_odd</h3>
        </div>
        <script>
            SyntaxHighlighter.defaults["gutter"] = false;
            SyntaxHighlighter.all();
        </script>
    </body>
</html>
